keyword<E> = E whitespace*
TYPE = keyword<"type">
LBRACKET = keyword<"{">
RBRACKET = keyword<"}">
COLON = keyword<":">

identifier -> &'input str
    = $([A-Za-z][A-Za-z0-9]+)

pub models -> Vec<DataModelTypeDeclaration>
    = m:model_type* { m }

model_type -> DataModelTypeDeclaration
    = TYPE n:identifier whitespace* LBRACKET f:model_field* RBRACKET whitespace* { 
        DataModelTypeDeclaration{ 
            name: n.to_owned(), 
            fields: f
        } 
    }

model_field -> DataModelFieldDeclaration
    = n:identifier COLON t:type_hierarchy d:directive* { 
        DataModelFieldDeclaration{
            name: n.to_owned(), 
            field_type: t, 
            directives: d 
        } 
    }

type_hierarchy -> DataModelTypeRef
    = '[' whitespace* c:type_hierarchy whitespace* ']' r:model_field_required whitespace* {
        let inner: Option<Box<DataModelTypeRef>> = Some(Box::new(c));
        DataModelTypeRef {
            name: "[]".to_owned(),
            inner_type: inner,
            required: r
        }
    }
    / t:identifier r:model_field_required whitespace* {
        DataModelTypeRef {
            name: t.to_owned(),
            inner_type: None,
            required: r
        }
    }

model_field_required -> bool
    = n:'!'? { 
        match n {
            Some(v) => true,
            None => false
        }
     }

directives -> Vec<DataModelFieldDirective>
    = d:directive* { d }

directive -> DataModelFieldDirective
    = '@' n:identifier whitespace* '(' whitespace* a:directive_arg* ')' whitespace* { 
        DataModelFieldDirective{
            name: n.to_owned(), 
            arguments: a
        } 
    }
    / '@' n:identifier whitespace* { 
        DataModelFieldDirective{
            name: n.to_owned(), 
            arguments: Vec::new() 
        } 
    }

directive_arg -> DataModelFieldDirectiveArg
 = n:identifier whitespace * COLON whitespace* v:doubleQuotedString whitespace* ','? whitespace* { 
     DataModelFieldDirectiveArg{
            name: n.to_owned(),
            quoted: true,
            value: v.to_string()
        } 
    }
 / n:identifier whitespace * COLON whitespace* v:identifier whitespace* ','? whitespace* { 
     DataModelFieldDirectiveArg{
            name: n.to_owned(),
            quoted: false,
            value: v.to_owned()
        } 
    }

/* hijacked from https://github.com/kevinmehall/rust-peg/blob/master/src/grammar.rustpeg */
doubleQuotedString -> String
    = '"' s:simpleDoubleQuotedCharacter* '"' { s.into_iter().collect() }

simpleDoubleQuotedCharacter -> char
    = !('"' / "\\" / eolChar) c:$. { c.chars().next().unwrap() }


eolChar
    = [\n\r\u{2028}\u{2029}]

/* Modeled after ECMA-262, 5th ed., 7.2. */
whitespace
    = #quiet<[ \t\n\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}]>